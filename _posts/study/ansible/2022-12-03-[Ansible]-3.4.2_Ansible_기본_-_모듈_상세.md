---
layout: post
title: "[Ansible] #3.4.2 Ansible 기본 - 모듈 상세"
subtitle: Ansible
date: '2022-12-03 4:00:00 +0900'
category: study
tags: ansible
image:
  path: /assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/logo.png
---

`Ansible` 의 기본 구성 요소인 `모듈` 중 `ping` , `command` 

<!--more-->

* this unordered seed list will be replaced by the toc
{:toc}

<br>

# 1. ping
---

```shell
ansible mgmt -m ping
```

![1](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/1.png)

`모듈` 을 사용한 명령문의 기본 정보에 대해서 알아보자.<br>
위 명령어는 `ping` 이라는 `모듈` 을 `mgmt` 에 실행한 결과를 반환한다.<br>
즉, 반환된 `ansible_facts` , `changed` , `ping` 등은 모두 `return value` 이다.

```shell
ansible mgmt -m ping -a 'data=xyz'
```

![2](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/2.png)

`ping` 모듈에 대해서 좀 더 보자면, 기본적으로 `ping` 이라는 프로토콜은 랜덤 문자를 보내고 그게 그대로 돌아오는지를 확인하는 매커니즘을 가지고있다.
`Ansible` 에서의 `ping` 모듈은 기본적으로 `ping` 이라는 값을 보내서 `pong` 이라는 값이 오는지를 확인한다.<br>
위 명령어는 이 `pong` 대신, `xyz` 라는 값을 반환하고, 확인하도록 변경하였다.<br>
이러한 기능, 옵션 등을 `Specification`이라고 하며, `ansible-doc` 에서 확인할 수 있다.

# 2. command 
---

```shell
ansible-doc command
```

![6](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/6.png)

위 명령어로 `command` 에 대한 정보를 쭉 보다보면 다음과 같은 설명이 있다.

![7](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/7.png)

`OPTIONS` 항목에 대한 설명중 `free_form` 이라는 것이 있다.<br>
자유형식이라는 뜻으로, 설명을 읽어보면 실행시킬 명령을 자유형식의 문자열로 넣으라고 안내되어있다.<br>
또한 이는 실제 파라미터가 아니며, 단지 자유형식이라는 의미이다.<br>
따라서 다음과 같이 자유롭게 명령을 옵션으로 넣을 수 있다.

```shell
ansible mgmt -m command -a 'id'
ansible mgmt -m command -a 'ls -l'
ansible mgmt -m command -a 'ps'
```

![8](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/8.png)

하지만 다음 명령문을 보자.

```shell
ansible mgmt -m command -a 'ps | grep python3'
```

![9](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/9.png)

실패한다.<br>

일단 기본적으로 `부모 프로세스` 와 `자식 프로세스` 에 대한 이해가 필요하다.<br>
`부모 프로세스` 는 `bash` 라고 생각하고, `자식 프로세스` 는 `bash` 에서 `ls` 를 실행한다고 생각하자.<br>
`부모 프로세스` 인 `bash` 는 실행중이고, `bash` 에서 `ls` 를 실행하려면 `자식 프로세스` 에게 `fork()` 를 하게 된다.<br>
즉 메모리를 복사하게 된다.<br>
그리고 `부모 프로세스` 는 `자식 프로세스` 가 종료할 때 까지 `wait()` , 대기하게 된다.<br>
그 동안 `자식 프로세스` 는 `exec()` , 실행하게 된다.<br>
여기서의 `fork()` , `wait()` , `exec()` 는 모두 `C` 함수들이다.<br>
`Linux` 는 `C` 로 만들어져있기 때문이다.<br>
`자식 프로세스` 에서의 `ls` 가 끝나게 되면, `exit()`, 종료를 하게 되고 이때 `return code` 를 같이 전송을 시킨다.<br>
기본적으로 `return code` 는 `0` 만이 정상 종료이고, 나머지 모든 값은 비정상 종료이다.

```shell
ls
echo $?
```

![10](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/10.png)

`echo $?` 의 결과값 `0` 이 방금 실행한 프로세스, `ls` 의 `return code` 이다.

```shell
ls -K
echo $?
```

![11](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/11.png)

이번에는 `ls -K` 에서 오류가 발생했다.<br>
`ls` 에 `-K` 라는 옵션은 존재하지 않는다.<br>
따라서 해당 프로세스는 비정상 종료하며, `return code` 로 `2` 를 반환했음을 알 수 있다.
`2` 가 무엇을 의미하는지는 다음을 통해 알 수 있다.

```shell
man ls
```

![12](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/12.png)

쭉 내리면, `Exit status` 에서 `2` 가 무엇을 의미하는지가 나온다.<br>
이는 각 명령어마다 다 다르기 때문에 모든 명령어의 `status` 가 의미하는 자세한 바를 외우기는 힘드지만, 공통적으로 `0` 이 의미하는 바는 정상 종료이다.

다시 돌아와서, 그럼 다음의 명령어와 결과를 다시 보자.

```shell
ansible mgmt -m command -a 'ps | grep python3'
```

![9](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/9.png)

`return code` `1` , 즉 실패다.<br>
이유는 간단하다.<br>
우리는 앞서 `command` 가 `쉘` 을 사용하지 않는 `모듈` 이라는 것을 배웠다.<br>
하지만 인자로 들어간 `|` 는 `쉘` 의 기능이므로, 오류가 발생한것이다.<br>
다음의 명령과 비교해보자.<br>

```shell
ansible mgmt -m shell -a 'ps | grep python3'
```

![13](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/13.png)

잘 실행된다.

# 3. copy

```shell
echo "hello" > hello.txt
cat hello.txt
ansible mgmt -m copy -a 'src=hello.txt dest=/tmp/hello.txt'
```

![3](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/3.png)

`dest` 는 원격지의 절대경로, `src` 는 로컬 상대경로, 절대경로 로 쓰면 된다.<br>
참고로 `ansible-doc` 으로 `copy` 의 `spec` 을 보면, 다른 옵션은 앞에 `-` 가 붙어있지만 `dest` 는 앞에 `=` 이 붙어있다.<br>
이는 `mandatory` , 즉 필수 옵션이라는 뜻이다.

파일이 복사되었기 때문에, 변경 내역이 있으므로 `“changed”` 는 `true` 가 되고, 이는 상태가 계속 변하는 `가변 인프라` 임을 나타낸다.


```shell
ansible mgmt -m copy -a 'src=hello.txt dest=/tmp/hello.txt'
```

![4](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/4.png)

한 번 더 실행시, `SUCCESS` 라고 뜨지만 `"changed"` 는 `false` 이다.<br>
즉 실행은 되었지만, 결론적으로 복사는 되지 않은것이다.<br>
동일한 파일이 이미 존재하기 때문이다.<br>
만약에 파일 내용을 바꾸고 명령을 실행하면, 파일이 달라졌기 때문에 복사가 된다 !<br>

즉 파일의 `"checksum"` 으로 파일명 뿐만 아니라 내용까지도 감안해서 복사를 진행한다.

```shell
rm hello.txt
```

다음 실습을 위해 `control1` 노드에서 `hello.txt` 를 지운다.

# 4. fetch
---

```shell
ansible mgmt -m fetch -a 'src=/tmp/hello.txt dest=./'
ls
ls node1/tmp/hello.txt
```

![5](/assets/img/study_Ansible/2022-12-03-[Ansible]-3.4.2_Ansible_기본_-_모듈_상세/5.png)

`fetch` 는 가져옴을 뜻한다.<br>
이 때 `src` 는 `mgmt` 가, `dest` 는 `control1` 이 될 것이다.<br>
결과, `control1` 에 `node1` 이란 폴더가 생기게 되고, 여기 안에 디렉토리가 생기면서 파일을 가져오게 된다.<br>
왜 이런식으로 `fetch` 가 이루어질까 ? <br>
만약 우리가 대상 노드를 여러개를 지정한 경우, 즉 그룹을 대상으로 지정한 경우, 겹치게 되므로 노드마다 디렉토리를 만든 다음 그 안에 파일을 가져오게 된다.

```shell
rm -rf node1/
```

다음 실습을 위해 `control1` 노드에서 `node1` 을 지운다.

# 5. file
---

